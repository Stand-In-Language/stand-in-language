id = \x -> x

and = \a b -> if a then (if b then 1 else 0) else 0

or = \a b -> if a then 1 else b

not = \x -> if x then 0 else 1

succ = \x -> (x,0)

d2c = \n f b -> { id
                , \recur i  -> f (recur (left i))
                , \i -> b
                } n

c2d = \c -> c succ 0

dPlus = \a b -> d2c b succ a

plus = \m n f x -> m f (n f x)

dTimes = \a b -> d2c b (\x -> dPlus a x) 0

times = \m n f -> m (n f)

dPow = \a b -> d2c b (dTimes a) (succ 0)

pow = \m n -> n m

dMinus = \a b -> d2c b (\x -> left x) a

minus = \a b -> d2c (b (\x -> left x) (c2d a))

range = \a b -> { \i -> dMinus b i
                , \recur i -> (i, recur (i,0))
                , \i -> 0
                } a

map = \f -> { id
            , \recur l -> (f (left l), recur (right l))
            , \l -> 0
            }

foldr = \f b ta -> let fixed = { id
                               , \recur l accum -> f (left l) (recur (right l) accum)
                               , \l accum -> accum
                               }
                   in fixed ta b

foldl = \f b ta -> let fixed = { id
                               , \recur l accum -> recur (right l) (f accum (left l))
                               , \l accum -> accum
                               }
                   in fixed ta b

zipWith = \f a b -> let fixed = { \ab -> and (left ab) (right ab)
                                , \recur ab -> (f (left (left ab)) (left (right ab))
                                               , recur (right (left ab), right (right ab))
                                               )
                                , \ab -> 0
                                }
                    in fixed (a,b)

filter = \f -> foldr (\a b -> if f a then (a, b) else b) 0

dEqual = \a b -> let equalsOne = \x -> if x then (not (left x)) else 0
                 in if a then equalsOne (d2c (left a) (\x -> left x) b)
                         else not b

dDiv = \a b -> { \p       -> dMinus (left p) (right p)
               , \recur p -> succ (recur (dMinus (left p) (right p), right p))
               , \p       -> if (dEqual (left p) (right p)) then succ 0 else 0
               } (a, b)

listLength = foldr (\a b -> succ b) 0

listEqual = \a b -> let pairsEqual = zipWith dEqual a b
                        lengthEqual = dEqual (listLength a) (listLength b)
                    in foldr and 1 (lengthEqual,pairsEqual)

listPlus = \a b -> foldr (\x l -> (x,l)) b a

flip = \f a b -> f b a

-- functional concatenation
con  = \f g x -> g (f x)

concat = foldr listPlus 0

drop = \n l -> n (\x -> right x) l

take = \n l -> let lengthed = n (\x -> (0,x)) 0
               in zipWith (\a b -> a) l lengthed

factorial = \n -> foldr (\a b -> times (d2c a) b) $1 (range 1 (n,0))

dFactorial = \n -> factorial n succ 0

quicksort = { \l -> right l
            , \recur l -> let t = left l
                              test = \x -> dMinus x t
                              p1 = filter test (right l)
                              p2 = filter (\x -> not (test x)) (right l)
                          in listPlus (recur p2) (t,(recur p1))
            , id
            }

abort = \str -> let x : (\y -> listPlus "abort: " str) = 1
                in x

assert = \t s -> if not t then (1, s) else 0

-- useful for making sure main input isn't unbounded
truncate = \n ->
  let layer = \recur current -> if current
                                then (recur (left current), recur (right current))
                                else 0
  in n layer (\x -> 0)

min = \a b -> { \p -> and (left p) (right p)
              , \recur p -> recur (left (left p), left (right p))
              , \p -> if (left p) then b else a
              } (a,b)

max = \a b -> { \p -> and (left p) (right p)
              , \recur p -> recur (left (left p), left (right p))
              , \p -> if (left p) then a else b
              } (a,b)

fakeRecur = \n t r b -> n (\rec i -> if t i then r rec i else b i) b

dMod = \a b ->
  { \p       -> dMinus (left p) (right p)
  , \recur p -> recur (dMinus (left p) (right p), right p)
  , \p       -> left p
  } (a, b)

gcd = \a b ->
  { \p -> not (dEqual (right p) 0)
  , \recur p -> recur (right p, dMod (left p) (right p))
  , \p -> left p
  } (a,b)

lcm = \a b -> dDiv (dTimes a b) (gcd a b)

Rational = \n d ->
  if dEqual d 0 then ("E", "Denominator cannot be zero")
  else
    let g   = gcd n d
        num = dDiv n g
        den = dDiv d g
    in ("R", (num,den))

rPlus = \a b ->
  let n1 = left (right a)
      d1 = right (right a)
      n2 = left (right b)
      d2 = right (right b)
      num = dPlus (dTimes n1 d2) (dTimes n2 d1)
      den = dTimes d1 d2
  in Rational num den

rTimes = \a b ->
  if not (dEqual (left  a) "R") then a
  else if not (dEqual (left b) "R") then b
  else let n1 = left (right a)
           d1 = right (right a)
           n2 = left (right b)
           d2 = right (right b)
           num = dTimes n1 n2
           den = dTimes d1 d2
       in Rational num den

